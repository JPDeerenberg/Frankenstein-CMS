<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Frankenstein CMS üßü‚Äç‚ôÇÔ∏è</title>
    <style>
      :root {
        --main-bg: #2c3e50;
        --panel-bg: #34495e;
        --accent: #27ae60; /* Changed to Green because... reanimated. */
        --text: #ecf0f1;
      }
      body {
        font-family: "Segoe UI", sans-serif;
        padding: 0;
        margin: 0;
        background: var(--main-bg);
        color: var(--text);
        height: 100vh;
        display: flex;
        flex-direction: column;
      }
      .screen {
        display: none;
        padding: 20px;
        height: 100%;
        box-sizing: border-box;
      }
      .screen.active {
        display: flex;
        flex-direction: column;
      }
      #login-screen {
        align-items: center;
        justify-content: center;
        text-align: center;
      }
      .login-box {
        background: var(--panel-bg);
        padding: 40px;
        border-radius: 10px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        width: 100%;
        max-width: 400px;
      }
      #dashboard-screen {
        flex-direction: row;
      }
      .sidebar {
        width: 250px;
        background: var(--panel-bg);
        padding: 20px;
        display: flex;
        flex-direction: column;
        border-right: 1px solid #222;
        z-index: 100;
      }
      .main-content {
        flex: 1;
        padding: 20px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        position: relative;
      }
      #editor-wrapper {
        background: white; /* This will be the background behind the Shadow Host */
        color: black;
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        border-radius: 4px;
        position: relative;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
      }
      /* The Shadow Host */
      #editor-host {
        display: block;
        min-height: 100%;
        outline: none;

        /* FIX: Trap 'fixed' position elements (like navbars) inside the box */
        contain: content;
        position: relative;
        background: white;
      }

      /* Toolbar styling */
      #floating-toolbar {
        position: absolute;
        display: none;
        background: #222;
        padding: 5px;
        border-radius: 5px;
        z-index: 99999;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        transform: translateX(-50%);
      }
      #floating-toolbar button {
        background: transparent;
        color: white;
        border: none;
        padding: 5px 10px;
        margin: 0;
        width: auto;
        cursor: pointer;
        font-size: 14px;
      }
      #floating-toolbar button:hover {
        background: var(--accent);
        color: white;
      }
      #floating-toolbar .divider {
        display: inline-block;
        width: 1px;
        height: 15px;
        background: #555;
        margin: 0 5px;
        vertical-align: middle;
      }
      h2 {
        margin-top: 0;
        color: var(--accent);
      }
      input {
        width: 100%;
        padding: 12px;
        margin: 8px 0;
        background: #222;
        border: 1px solid #555;
        color: white;
        border-radius: 4px;
        box-sizing: border-box;
      }
      button {
        width: 100%;
        padding: 12px;
        margin-top: 10px;
        background: var(--accent);
        color: white;
        border: none;
        cursor: pointer;
        border-radius: 4px;
        font-weight: bold;
        transition: 0.2s;
      }
      button:hover {
        filter: brightness(1.1);
      }
      button.secondary {
        background: #7f8c8d;
      }
      button.danger {
        background: #c0392b;
        margin-top: auto;
      }
      #file-list {
        list-style: none;
        padding: 0;
        margin-top: 20px;
        overflow-y: auto;
      }
      #file-list li {
        padding: 10px;
        border-bottom: 1px solid #444;
        cursor: pointer;
        display: flex;
        align-items: center;
        word-break: break-all;
      }
      #file-list li:hover {
        background: rgba(255, 255, 255, 0.1);
        color: var(--accent);
      }
      #file-list li.active {
        background: var(--accent);
        color: white;
      }
      .status-bar {
        margin-top: 10px;
        font-size: 0.85em;
        color: #bdc3c7;
        text-align: center;
      }
      .current-file-display {
        background: #222;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 4px;
        font-family: monospace;
        display: flex;
        justify-content: space-between;
        align-items: center;
        z-index: 50;
      }
    </style>
  </head>
  <body>
    <div id="floating-toolbar">
      <button onclick="execCmd('bold')" title="Bold"><b>B</b></button>
      <button onclick="execCmd('italic')" title="Italic"><i>I</i></button>
      <button onclick="execCmd('underline')" title="Underline"><u>U</u></button>
      <div class="divider"></div>
      <button onclick="formatBlock('H2')" title="Heading 2">H2</button>
      <button onclick="formatBlock('H3')" title="Heading 3">H3</button>
      <button onclick="formatBlock('P')" title="Paragraph">P</button>
      <div class="divider"></div>
      <button onclick="createLink()" title="Link">üîó</button>
      <button onclick="execCmd('unlink')" title="Remove link">‚ùå</button>
    </div>

    <div id="login-screen" class="screen active">
      <div class="login-box">
        <h2>üßü‚Äç‚ôÇÔ∏è Frankenstein 2.0</h2>
        <p style="font-size: 0.8em; opacity: 0.7">
          Now with 50% less chance of self-destruction.
        </p>
        <input
          type="password"
          id="cfg-token"
          placeholder="GitHub Personal Access Token"
        />
        <input type="text" id="cfg-owner" placeholder="GitHub Username" />
        <input type="text" id="cfg-repo" placeholder="Repo Name" />
        <button onclick="saveConfigAndLogin()">üîì Login (Session)</button>
        <div id="login-msg" class="status-bar"></div>
      </div>
    </div>

    <div id="dashboard-screen" class="screen">
      <div class="sidebar">
        <h3>üóÇ Files</h3>
        <button class="secondary" onclick="fetchFileList()">
          üîÑ Refresh List
        </button>
        <ul id="file-list">
          <li style="font-style: italic; opacity: 0.5">Loading...</li>
        </ul>
        <button class="danger" onclick="logout()">üö™ Log out</button>
      </div>

      <div class="main-content">
        <div class="current-file-display">
          <span id="active-filename">No file selected</span>
          <span
            id="save-status"
            style="font-size: 0.8em; color: #f1c40f"
          ></span>
        </div>

        <div id="editor-wrapper">
          <div id="editor-host"></div>
        </div>

        <button
          onclick="slaOp()"
          id="saveBtn"
          style="
            display: none;
            width: auto;
            align-self: flex-end;
            padding: 10px 30px;
            margin-top: 10px;
            z-index: 50;
          "
        >
          üíæ Save & Push to Git
        </button>
      </div>
    </div>

    <script>
      let config = { token: "", owner: "", repo: "" };
      let currentSha = "";
      let originalRawHTML = ""; // Store raw string for serializer
      let currentPath = "";
      // Shadow Root Reference
      let shadow = null;

      window.onload = () => {
        // FIX 2: Check SessionStorage instead of LocalStorage
        const saved = sessionStorage.getItem("frankenstein_cfg");
        if (saved) {
          config = JSON.parse(saved);
          showDashboard();
        }
        initToolbar();
      };

      function initToolbar() {
        const toolbar = document.getElementById("floating-toolbar");

        // Listen to selection changes on the document (Shadow DOM selection bubbles up in some browsers, but we need to check activeElement)
        document.addEventListener("selectionchange", updateToolbarPos);

        // Fallback for when interacting inside Shadow DOM
        setInterval(updateToolbarPos, 200);

        function updateToolbarPos() {
          if (!shadow) return;
          const selection = shadow.getSelection();

          if (selection && selection.rangeCount > 0 && !selection.isCollapsed) {
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();

            // Adjust for the editor wrapper position since rect is viewport relative
            if (rect.width > 0 && rect.height > 0) {
              toolbar.style.top = `${rect.top - 50}px`;
              toolbar.style.left = `${rect.left + rect.width / 2}px`;
              toolbar.style.display = "block";
              return;
            }
          }
          // Only hide if we aren't hovering the toolbar itself
          if (!toolbar.contains(document.activeElement)) {
            // delay hiding slightly
          }
        }

        // Hide on click outside
        document.addEventListener("mousedown", (e) => {
          if (!toolbar.contains(e.target) && e.target.id !== "editor-host") {
            toolbar.style.display = "none";
          }
        });

        toolbar.querySelectorAll("button").forEach((btn) => {
          btn.addEventListener("mousedown", (e) => {
            e.preventDefault(); // Prevent losing focus from editor
          });
        });
      }

      function execCmd(command, value = null) {
        // FIX 1: Still using execCommand (The Zombie), but strictly on the Shadow Document
        // Note: document.execCommand works on the active editable element (even in shadow) in most modern browsers.
        document.execCommand(command, false, value);
      }

      function createLink() {
        const url = prompt("Enter URL:", "https://");
        if (url) execCmd("createLink", url);
      }

      function formatBlock(tag) {
        execCmd("formatBlock", tag);
      }

      async function saveConfigAndLogin() {
        const token = document.getElementById("cfg-token").value.trim();
        const owner = document.getElementById("cfg-owner").value.trim();
        const repo = document.getElementById("cfg-repo").value.trim();
        const msgBox = document.getElementById("login-msg");

        if (!token || !owner || !repo) {
          msgBox.innerText = "Please fill in all fields.";
          msgBox.style.color = "red";
          return;
        }

        msgBox.innerText = "Connecting...";
        msgBox.style.color = "orange";

        try {
          const url = `https://api.github.com/repos/${owner}/${repo}`;
          const res = await fetch(url, {
            headers: { Authorization: `token ${token}` },
          });
          if (!res.ok) throw new Error(`Error ${res.status}: No access.`);
          const data = await res.json();
          msgBox.innerText = `Logged in: ${data.full_name}`;
          msgBox.style.color = "green";
          config = { token, owner, repo };
          // FIX 2: Save to SessionStorage (clears on tab close)
          sessionStorage.setItem("frankenstein_cfg", JSON.stringify(config));
          setTimeout(() => showDashboard(), 1000);
        } catch (e) {
          msgBox.innerText = e.message;
          msgBox.style.color = "#e74c3c";
        }
      }

      function logout() {
        if (confirm("Log out?")) {
          sessionStorage.removeItem("frankenstein_cfg");
          location.reload();
        }
      }
      function showDashboard() {
        document.getElementById("login-screen").classList.remove("active");
        document.getElementById("dashboard-screen").classList.add("active");
        fetchFileList();
      }

      function resolvePath(basePath, relativePath) {
        if (relativePath.startsWith("/")) return relativePath.substring(1);
        const stack = basePath
          ? basePath.split("/").filter((p) => p.length > 0)
          : [];
        const parts = relativePath.split("/");
        for (const part of parts) {
          if (part === "." || part === "") continue;
          if (part === "..") {
            if (stack.length > 0) stack.pop();
          } else {
            stack.push(part);
          }
        }
        return stack.join("/");
      }

      async function loadAndInjectStyles(doc) {
        // FIX 4: Inject styles into Shadow DOM, not main document
        const links = doc.querySelectorAll('link[rel="stylesheet"]');
        if (links.length === 0) return;

        const currentDir = currentPath.includes("/")
          ? currentPath.substring(0, currentPath.lastIndexOf("/"))
          : "";

        await Promise.all(
          Array.from(links).map(async (link) => {
            const href = link.getAttribute("href");
            if (!href || href.startsWith("http") || href.startsWith("//"))
              return;
            const apiPath = resolvePath(currentDir, href);
            try {
              const url = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${apiPath}`;
              const res = await fetch(url, {
                headers: { Authorization: `token ${config.token}` },
              });
              if (!res.ok) throw new Error("404 CSS");
              const data = await res.json();
              const cssContent = decodeURIComponent(
                escape(window.atob(data.content))
              );

              // Inject into Shadow Root
              const styleTag = document.createElement("style");
              styleTag.textContent = cssContent;
              if (shadow) shadow.appendChild(styleTag);
            } catch (e) {
              console.warn("Failed CSS:", apiPath);
            }
          })
        );
      }

      async function fixImagesWithAuth(doc) {
        const images = doc.querySelectorAll("img");
        const currentDir = currentPath.includes("/")
          ? currentPath.substring(0, currentPath.lastIndexOf("/"))
          : "";

        const promises = Array.from(images).map(async (img) => {
          const src = img.getAttribute("src");
          if (!src || src.startsWith("http") || src.startsWith("data:")) return;

          img.setAttribute("data-original-src", src);
          const apiPath = resolvePath(currentDir, src);
          try {
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${apiPath}`;
            const res = await fetch(url, {
              headers: {
                Authorization: `token ${config.token}`,
                Accept: "application/vnd.github.v3.raw",
              },
            });
            if (!res.ok) throw new Error("404 Img");
            const blob = await res.blob();
            img.src = URL.createObjectURL(blob);
          } catch (e) {
            console.warn(`Image broken: ${src}`, e);
            img.style.border = "2px solid red";
          }
        });
        await Promise.all(promises);
      }

      async function fetchFileList() {
        const listEl = document.getElementById("file-list");
        listEl.innerHTML = '<li style="opacity:0.5">Searching...</li>';
        try {
          const res = await fetch(
            `https://api.github.com/repos/${config.owner}/${config.repo}/contents/`,
            {
              headers: { Authorization: `token ${config.token}` },
            }
          );
          if (!res.ok) throw new Error("Error fetching list.");
          const data = await res.json();
          if (!Array.isArray(data)) throw new Error("No files.");
          const htmlFiles = data.filter(
            (f) => f.name.endsWith(".html") && f.type === "file"
          );

          listEl.innerHTML = "";
          if (htmlFiles.length === 0) {
            listEl.innerHTML = "<li>No HTML found ü§∑‚Äç‚ôÇÔ∏è</li>";
            return;
          }

          htmlFiles.forEach((file) => {
            const li = document.createElement("li");
            li.innerText = file.name;
            li.onclick = () => loadFile(file.path, li);
            listEl.appendChild(li);
          });
        } catch (e) {
          listEl.innerHTML = `<li style="color:red; font-size:0.8em">${e.message}</li>`;
        }
      }

      async function loadFile(path, menuElement) {
        document
          .querySelectorAll("#file-list li")
          .forEach((l) => l.classList.remove("active"));
        if (menuElement) menuElement.classList.add("active");
        currentPath = path;
        document.getElementById("active-filename").innerText = path;

        // FIX 4: Initialize Shadow DOM
        const host = document.getElementById("editor-host");
        if (!host.shadowRoot) {
          shadow = host.attachShadow({ mode: "open" });
        } else {
          shadow = host.shadowRoot;
        }

        // Default styling for the shadow dom editor area
        shadow.innerHTML = `<div style="padding: 20px; color: #666;">Loading...</div>`;
        document.getElementById("saveBtn").style.display = "none";

        try {
          const res = await fetch(
            `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${path}`,
            {
              headers: { Authorization: `token ${config.token}` },
            }
          );
          if (!res.ok) throw new Error("File not found.");
          const data = await res.json();
          currentSha = data.sha;

          const rawHTML = decodeURIComponent(escape(window.atob(data.content)));
          originalRawHTML = rawHTML; // Save for XMLSerializer later

          const parser = new DOMParser();
          const doc = parser.parseFromString(rawHTML, "text/html");

          // Inject CSS into Shadow DOM
          await loadAndInjectStyles(doc);
          await fixImagesWithAuth(doc);

          // Render Body into Shadow DOM
          // We wrap it in a div to ensure we have a block to edit, or just dump body children
          shadow.innerHTML = ""; // Clear loader

          // Re-add styles that were just fetched (since we cleared innerHTML)
          // Actually, loadAndInjectStyles appends to shadow, so we need to be careful not to wipe them.
          // Better approach: Create a container for content.
          const styleContainer = document.createElement("div");
          styleContainer.id = "cms-styles";
          shadow.appendChild(styleContainer);

          // Re-fetch styles implies we append them again. Let's adjust logic slightly:
          // We will let loadAndInjectStyles append to shadow.

          // Insert Body Content
          const contentDiv = document.createElement("div");
          contentDiv.id = "editable-body";
          contentDiv.innerHTML = doc.body.innerHTML;
          contentDiv.style.outline = "none";
          contentDiv.style.minHeight = "200px";
          shadow.appendChild(contentDiv);

          // Re-run style injection now that shadow is ready
          await loadAndInjectStyles(doc);

          const editables = shadow.querySelectorAll("[data-editable]");
          if (editables.length > 0) {
            editables.forEach((el) => (el.contentEditable = "true"));
          } else {
            // If no data-editable, make the whole body editable? Or warn?
            // For safety, let's just warn if nothing is editable
            if (contentDiv.innerText.trim().length === 0)
              contentDiv.innerHTML = "<p>Empty file</p>";
          }

          document.getElementById("saveBtn").style.display = "inline-block";
        } catch (e) {
          shadow.innerHTML = `<p style="color:red">${e.message}</p>`;
        }
      }

      async function slaOp() {
        const btn = document.getElementById("saveBtn");
        const status = document.getElementById("save-status");
        btn.disabled = true;
        btn.innerText = "Serializing...";
        status.innerText = "Saving...";

        try {
          // FIX 3: Robust Saving with XMLSerializer
          // 1. Get the current edited content from Shadow DOM
          const contentContainer = shadow.getElementById("editable-body");
          const clone = contentContainer.cloneNode(true);

          // Clean up editable attributes
          clone
            .querySelectorAll("[data-editable]")
            .forEach((el) => el.removeAttribute("contenteditable"));

          // Restore images to original src
          const images = clone.querySelectorAll("img[data-original-src]");
          images.forEach((img) => {
            img.src = img.getAttribute("data-original-src");
            img.removeAttribute("data-original-src");
          });

          // 2. Parse the ORIGINAL file again to get a clean DOM structure (Head, HTML attrs)
          const parser = new DOMParser();
          const doc = parser.parseFromString(originalRawHTML, "text/html");

          // 3. Swap the body content
          doc.body.innerHTML = clone.innerHTML;

          // 4. Use XMLSerializer to generate valid HTML string
          const serializer = new XMLSerializer();
          const newHTML = serializer.serializeToString(doc);

          const encodedContent = window.btoa(
            unescape(encodeURIComponent(newHTML))
          );

          const res = await fetch(
            `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${currentPath}`,
            {
              method: "PUT",
              headers: {
                Authorization: `token ${config.token}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                message: `Update ${currentPath} via Frankenstein`,
                content: encodedContent,
                sha: currentSha,
              }),
            }
          );

          if (res.ok) {
            const data = await res.json();
            currentSha = data.content.sha;
            // Update originalRawHTML so next save is based on this version
            originalRawHTML = newHTML;
            status.innerText = "‚úÖ Saved!";
            setTimeout(() => (status.innerText = ""), 3000);
          } else {
            throw new Error((await res.json()).message);
          }
        } catch (e) {
          alert("Error: " + e.message);
          status.innerText = "‚ùå";
        } finally {
          btn.disabled = false;
          btn.innerText = "üíæ Save & Push to Git";
        }
      }
    </script>
  </body>
</html>
